#!/usr/bin/python


import dns.resolver
import re
import sys
import optparse
import logging

usage = "usage: %prog give the program a DNS a Name Server IP and a maximum recursion depth. [options]"
parser = optparse.OptionParser(usage=usage)
parser.add_option("-u","--usage", action = "store_true", dest = "optionUsage", help = "Show List of Options")
parser.add_option("-v","--verbose", action = "store_true", dest = "verbose", default = False, help = "Turn On program output")

(options, args) = parser.parse_args()


def usage():
	pattern = 'Option'
	count = 0
	start = 0
	flag = True
	optionList = parser.option_list
	strOptionList = str(optionList)
	greaterThanFind = 0
	while flag:
		a = strOptionList.find(pattern, start)

		if a == -1:
			flag = False
		else:
			count += 1
			start = a + 1
			dashFind = strOptionList.find('-', greaterThanFind)
			greaterThanFind = strOptionList.find('>', greaterThanFind + 1)
			options = strOptionList[dashFind:greaterThanFind]
			print(options)
	sys.exit(10)


#searches a domain
def domainSearch(domainCheck, counter, depth=0):
	
	print(depth)
	depthCheck(depth)
	
	#searches for TXT records
	responses = resolver.query(domainCheck, "TXT")
	
	#goes through each response
	for currentRecord in responses:
		
		#checks if records are spf
		if 'spf2.0/pra' or 'v=spf1' is str(currentRecord).split(' ')[0]:
			currentRecordString = str(currentRecord)
			splitString = (currentRecordString.split())

			#looks for ipv4 addresses and adds them to a list
			if any("ip4:" in stringSegment for stringSegment in splitString):
				ipv4 = (" ".join(stringSegment for stringSegment in splitString if 'ip4' in stringSegment))
				noIpv4 = ipv4.replace("ip4:", "")
				splitIpv4.extend(noIpv4.split())

				#checks list for ipv4 address. If it is not in the list it adds it.
				for ipv4Address in splitIpv4[:]:
					if ipv4Address not in ipv4List:
						ipv4List.append(ipv4Address)
				
			#looks for ipv6 addresses and adds them to a list 
			if any("ip6:" in stringSegment for stringSegment in splitString):
				ipv6 = (" ".join(stringSegment for stringSegment in splitString if 'ip6' in stringSegment))
				noIpv6 = ipv6.replace("ip6:", "")
				splitIpv6.extend(noIpv6.split())

				#checks list for ipv6 address. If it is not in the list it adds it.
				for ipv6Address in splitIpv6[:]:
					if ipv6Address not in ipv6List:
						ipv6List.append(ipv6Address)

			if any("mx" in stringSegment for stringSegment in splitString):
				mxLookUp(domain)

			#looks for domains and adds them to a list 
			if any("include:" in stringSegment for stringSegment in splitString):
				domains = (" ".join(stringSegment for stringSegment in splitString if 'include' in stringSegment))
				noInclude = domains.replace("include:", "")
				splitList.extend(noInclude.split())
				
				#checks list for a domain. If it is not in the list it adds it.
				for specificDomain in splitList[:]:
					if specificDomain not in domainList:
						domainList.append(specificDomain)	
			try:
				counter += 1
				domainSearch(domainList[counter-1], counter, depth=depth+1)
			except:
				counter -= 1


def mxLookUp(domain):
	mxResponses = dns.resolver.query(domain, 'MX')
	for response in mxResponses:
		mxRecord = str(response).split()[1]
		if mxRecord not in mxList:
			mxList.append(mxRecord)
		for record in mxList:
			aRecordLookUp(record)
			quadARecordLookUp(record)

def aRecordLookUp(domain):
	aResponses = dns.resolver.query(domain, 'A')
	for response in aResponses:
		aRecord = str(response)
		if aRecord not in aResponseList:
			aResponseList.append(aRecord)
	
def quadARecordLookUp(domain):
	quadAResponses = dns.resolver.query(domain, 'AAAA')
	for response in quadAResponses:
		quadARecord = str(response)
		if quadARecord not in quadAResponseList:
			quadAResponseList.append(quadARecord)

def depthCheck(currentDepth):
	if currentDepth > maxDepth:
		global toDeep
		toDeep = True
	assert currentDepth < maxDepth 


if options.optionUsage == True:
	usage()

logging.basicConfig(level = logging.WARNING if not options.verbose else logging.INFO, format = "%(message)s")

if options.verbose == True:
	
	try:
		domain = sys.argv[2]
		nameServer = sys.argv[3]
	except IndexError:
		logging.warning("SYNTAX ERROR: This program requires both a domain and a name server to execute.")
		usage()
	try:
		maxDepth = int(sys.argv[4])
	except:
		logging.warning("Either no max depth was set or it was invalid.  Max depth was defaulted to 50.")
		maxDepth = 50
else:
	try:
		domain = sys.argv[1]
		nameServer = sys.argv[2]
	except IndexError:
                logging.warning("SYNTAX ERROR: This program requires both a domain and a name server to execute.")
                usage()
	try:
        	maxDepth = int(sys.argv[3])
	except:
		logging.warning("Either no max depth was set or it was invalid.  Max depth was defaulted to 50.")
        	maxDepth = 50


resolver = dns.resolver.Resolver()
domainList = []
splitList = []
resolver.nameservers = [nameServer]

ipv4List = []
splitIpv4 = []

ipv6List = []
splitIpv6 = []

mxList = []
aResponseList = []
quadAResponseList = []

toDeep = False

counter = 0

domainSearch(domain, counter)

if toDeep:
	logging.warning("Maximum Depth Was Reached")

print(len(ipv4List))
print(len(ipv6List))
logging.info("ipv4:" + (" ipv4:".join(ipv4List))+'\n')
logging.info("ipv6:" + (" ipv6:".join(ipv6List))+'\n')
logging.info(aResponseList)
logging.info(quadAResponseList)

